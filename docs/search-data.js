window.Aiken.initSearch([{"doc":"services/protocol_token","title":"find_own_protocol_policy_id","content":"find_own_protocol_policy_id(input_value: Value, nft_name: AssetName) -&gt; PolicyId\n Find own protocol NFT inside the value we are spending.\n Note that it&#39;s not required to check_own_protocol_token in tx inputs\n because it&#39;s already been checked for each output.","url":"services/protocol_token.html#find_own_protocol_policy_id"},{"doc":"services/protocol_token","title":"find_script_inputs_by_token","content":"find_script_inputs_by_token(\n  tx_inputs: List&lt;Input&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n) -&gt; List&lt;Input&gt;\n Find own protocol NFT inside transaction inputs.\n Note that it&#39;s not required to check_own_protocol_token in tx inputs\n because it&#39;s already been checked for each output.","url":"services/protocol_token.html#find_script_inputs_by_token"},{"doc":"services/protocol_token","title":"spends_protocol_nft_inputs","content":"spends_protocol_nft_inputs(\n  script_hash: ScriptHash,\n  protocol_nft: Asset,\n  utxo_count: Int,\n  tx_inputs: List&lt;Input&gt;,\n) -&gt; Bool\n A convenience function that calls find_script_inputs_by_token\n and also checks number of spent inputs","url":"services/protocol_token.html#spends_protocol_nft_inputs"},{"doc":"services/protocol_token","title":"find_script_outputs_by_token","content":"find_script_outputs_by_token(\n  tx_outputs: List&lt;Output&gt;,\n  script_hash: ScriptHash,\n  allowed_asset: PolicyId,\n  protocol_token: Asset,\n) -&gt; List&lt;Output&gt;\n Find own protocol NFT inside transaction outputs","url":"services/protocol_token.html#find_script_outputs_by_token"},{"doc":"services/protocol_token","title":"check_own_protocol_token","content":"check_own_protocol_token(\n  output_value: Value,\n  allowed_asset: PolicyId,\n  protocol_token: Asset,\n) -&gt; Bool\n Returns true if protocol NFT was found and it&#39;s the only asset except lovelace and one allowed","url":"services/protocol_token.html#check_own_protocol_token"},{"doc":"services/protocol_token","title":"skip_allowed_asset","content":"skip_allowed_asset(\n  policy_id: PolicyId,\n  name: AssetName,\n  amount: Int,\n  allowed_asset: PolicyId,\n) -&gt; Option&lt;(PolicyId, AssetName, Int)&gt;\n Skips allowed token: e.g. C3 fee payment token","url":"services/protocol_token.html#skip_allowed_asset"},{"doc":"services/protocol_token","title":"services/protocol_token","content":"","url":"services/protocol_token.html"},{"doc":"oracle/consensus","title":"median","content":"median(node_feeds: List&lt;NodeFeed&gt;) -&gt; OracleFeed\n","url":"oracle/consensus.html#median"},{"doc":"oracle/consensus","title":"consensus_by_iqr","content":"consensus_by_iqr(\n  node_feeds: Pairs&lt;NodeId, NodeFeed&gt;,\n  iqr_fence_multiplier: Percent,\n) -&gt; List&lt;NodeId&gt;\n Returns list of nodes which are not outliers using interquartile range algorithm (IQR).","url":"oracle/consensus.html#consensus_by_iqr"},{"doc":"oracle/consensus","title":"iqr_fences","content":"iqr_fences(\n  node_feeds: List&lt;NodeFeed&gt;,\n  iqr_fence_multiplier: Percent,\n) -&gt; (NodeFeed, NodeFeed)\n To ensure a more reliable outlier detection using IQR, it&#39;s advisable to have a sample size of at least 20-30 data points,\n i.e. five points per quartile.\n Naturally, minimum number of points is four, to have at least one element in earch quartile,\n but beware that IQR could become useless for sample sizes of 4-10.","url":"oracle/consensus.html#iqr_fences"},{"doc":"oracle/consensus","title":"oracle/consensus","content":"","url":"oracle/consensus.html"},{"doc":"services/nft_based_auth","title":"auth_by_nft","content":"auth_by_nft(\n  nft: PolicyId,\n  tx_inputs: List&lt;Input&gt;,\n  tx_outputs: List&lt;Output&gt;,\n) -&gt; Bool\n","url":"services/nft_based_auth.html#auth_by_nft"},{"doc":"services/nft_based_auth","title":"services/nft_based_auth","content":"","url":"services/nft_based_auth.html"},{"doc":"ext/cardano/value","title":"Asset","content":"Asset {\n  policy_id: PolicyId,\n  name: AssetName,\n}\n\nAsset { policy_id: PolicyId, name: AssetName }\n","url":"ext/cardano/value.html#Asset"},{"doc":"ext/cardano/value","title":"ext/cardano/value","content":"","url":"ext/cardano/value.html"},{"doc":"oracle/datum","title":"is_oracle_closing","content":"is_oracle_closing(reward_datum: RewardDatum) -&gt; Bool\n","url":"oracle/datum.html#is_oracle_closing"},{"doc":"oracle/datum","title":"has_no_rewards","content":"has_no_rewards(reward_transport: RewardTransportDatum) -&gt; Bool\n","url":"oracle/datum.html#has_no_rewards"},{"doc":"oracle/datum","title":"AggStateDatum","content":"AggStateDatum {\n  oracle_feed: OracleFeed,\n  expiry_timestamp: PosixTime,\n  created_at: PosixTime,\n}\n AggStateDatum contains an oracle feed - median taken from individual node feeds,\n an expiration timestamp marking time after which AggState can be consumed once again,\n and a created at timestamp for oracle users.\nAggStateDatum {\n  oracle_feed: OracleFeed,\n  expiry_timestamp: PosixTime,\n  created_at: PosixTime,\n}\n","url":"oracle/datum.html#AggStateDatum"},{"doc":"oracle/datum","title":"AggregateMessage","content":"AggregateMessage {\n  node_feeds: Pairs&lt;NodeId, NodeFeed&gt;,\n  timestamp: PosixTime,\n}\n\nAggregateMessage { node_feeds: Pairs&lt;NodeId, NodeFeed&gt;, timestamp: PosixTime }\n","url":"oracle/datum.html#AggregateMessage"},{"doc":"oracle/datum","title":"FeeConfig","content":"FeeConfig {\n  rate_nft: Option&lt;Asset&gt;,\n  reward_prices: RewardPrices,\n}\n\nFeeConfig { rate_nft: Option&lt;Asset&gt;, reward_prices: RewardPrices }\n","url":"oracle/datum.html#FeeConfig"},{"doc":"oracle/datum","title":"Node","content":"Node {\n  payment_vkh: VerificationKeyHash,\n  feed_vkh: VerificationKeyHash,\n}\n\nNode { payment_vkh: VerificationKeyHash, feed_vkh: VerificationKeyHash }\n","url":"oracle/datum.html#Node"},{"doc":"oracle/datum","title":"NodeFeed","content":"NodeFeed = Int\n\n","url":"oracle/datum.html#NodeFeed"},{"doc":"oracle/datum","title":"NodeId","content":"NodeId = Int\n\n","url":"oracle/datum.html#NodeId"},{"doc":"oracle/datum","title":"OracleDatum","content":"OracleDatum {\n  RewardAccount(RewardDatum)\n  RewardTransport(RewardTransportDatum)\n  AggState(Option&lt;AggStateDatum&gt;)\n}\n There are three types of oracle utxos:\n 1. RewardAccount - one for each oracle,\n    acts as single point of truth for oracle settings, node list, and reward distribution.\n 2. RewardTransport - many for each oracle, with possibility of scaling their number on demand,\n    users permorm ODV aggregation with those by providing node feeds list constructed off-chain.\n 3. AggState - each AggState utxo is complementary to RewardTransport, it containts the oracle feed value,\n    that will be referenced by a user of a DApp.\nRewardAccount(RewardDatum)\n\nRewardTransport(RewardTransportDatum)\n\nAggState(Option&lt;AggStateDatum&gt;)\n","url":"oracle/datum.html#OracleDatum"},{"doc":"oracle/datum","title":"OracleFeed","content":"OracleFeed = Int\n\n","url":"oracle/datum.html#OracleFeed"},{"doc":"oracle/datum","title":"OracleSettings","content":"OracleSettings {\n  platform_auth_nft: PolicyId,\n  closing_period_length: PosixTimeDiff,\n  reward_dismissing_period_length: PosixTimeDiff,\n  fee_token: Asset,\n}\n Immutable oracle settings.\n Rationale for immutability:\n * platform_auth_nft - oracle deployment corresponds to one unchanging &quot;platform&quot;\n * closing_period_length - oracle nodes will be sure that platform won&#39;t update this to a make very short interval\n * reward_dismissing_period_length - oracle nodes will be sure that platform won&#39;t update this to a make very short interval\n * fee_token - oracle nodes will be sure that platform won&#39;t update reward currency\nOracleSettings {\n  platform_auth_nft: PolicyId,\n  closing_period_length: PosixTimeDiff,\n  reward_dismissing_period_length: PosixTimeDiff,\n  fee_token: Asset,\n}\n","url":"oracle/datum.html#OracleSettings"},{"doc":"oracle/datum","title":"RewardDatum","content":"RewardDatum {\n  nodes_to_rewards: Pairs&lt;Node, Int&gt;,\n  fee_info: FeeConfig,\n  aggregation_liveness_period: PosixTimeDiff,\n  time_absolute_uncertainty: PosixTimeDiff,\n  iqr_fence_multiplier: Percent,\n  closing_period_started_at: Option&lt;PosixTime&gt;,\n}\n Mutable oracle settings and reward distribution data\nRewardDatum {\n  nodes_to_rewards: Pairs&lt;Node, Int&gt;,\n  fee_info: FeeConfig,\n  aggregation_liveness_period: PosixTimeDiff,\n  time_absolute_uncertainty: PosixTimeDiff,\n  iqr_fence_multiplier: Percent,\n  closing_period_started_at: Option&lt;PosixTime&gt;,\n}\n","url":"oracle/datum.html#RewardDatum"},{"doc":"oracle/datum","title":"RewardPrices","content":"RewardPrices {\n  node_fee: Int,\n  consensus_fee: Int,\n  platform_fee: Int,\n}\n\nRewardPrices { node_fee: Int, consensus_fee: Int, platform_fee: Int }\n","url":"oracle/datum.html#RewardPrices"},{"doc":"oracle/datum","title":"RewardTransportDatum","content":"RewardTransportDatum {\n  NoRewards\n  RewardConsensusPending { oracle_feed: OracleFeed, message: AggregateMessage }\n}\n RewardTransport utxo can be in two states:\n 1. NoRewards - waiting for user to submit tx with OdvAggregate redeemer;\n 2. RewardConsensusPending - waiting to calculate aggregation reward distribution\n    and transfer user provided fees into RewardAccount utxo.\nNoRewards\n\nRewardConsensusPending { oracle_feed: OracleFeed, message: AggregateMessage }\n","url":"oracle/datum.html#RewardTransportDatum"},{"doc":"oracle/datum","title":"oracle/datum","content":"","url":"oracle/datum.html"},{"doc":"oracle","title":"MintingRedeemer","content":"MintingRedeemer {\n  Mint\n  Scale\n  Burn\n}\n Types of actions for Oracle NFTs (protocol tokens)\n * Mint  - Oracle start: one time mint for RewardAccount; any number of mints for RewardTransport and AggState\n * Scale - Scale RewardTransport and AggState UTxOs: any number of mints/burns for RewardTransport and AggState\n * Burn  - Oracle close: all tokens are burned\nMint\n\nScale\n\nBurn\n","url":"oracle.html#MintingRedeemer"},{"doc":"oracle","title":"OracleRedeemer","content":"OracleRedeemer {\n  OdvAggregate\n  CalculateRewards\n  NodeCollect\n  PlatformCollect\n  UpdateSettings\n  SetFeeConfig\n  AddNodes\n  DelNodes\n  ScaleDown\n  DismissRewards\n  CloseOracle\n  RemoveOracle\n}\n Types of actions for Oracle smart contract\n * OdvAggregate - user sends on demand validation request together with oracle nodes message collected off-chain\n * CalculateRewards - nodes and platform can calculate reward consensus transferring user provided fees to reward UTxO\n * NodeCollect - oracle node collects rewards\n * PlatformCollect - oracle platform collects rewards\n * UpdateSettings - oracle platform changes consensus settings\n * SetFeeConfig - oracle platform changes reward fee configuration\n * AddNodes - oracle platform adds new nodes\n * DelNodes - oracle platform deletes nodes\n * ScaleDown - oracle platform burns RewardTransport and AggState NFTs, destroying corresponding UTxOs\n * DismissRewards - oracle platform turns RewardTransport UTxOs with pending rewards calculations into NoRewards\n * CloseOracle - oracle platform starts closing period, when nodes can still calculate disregarded rewards\n * RemoveOracle - oracle closing period ends and platform destroys all UTxOs and all NFTs\nOdvAggregate\n\nCalculateRewards\n\nNodeCollect\n\nPlatformCollect\n\nUpdateSettings\n\nSetFeeConfig\n\nAddNodes\n\nDelNodes\n\nScaleDown\n\nDismissRewards\n\nCloseOracle\n\nRemoveOracle\n","url":"oracle.html#OracleRedeemer"},{"doc":"oracle","title":"aggstate_token_name","content":"aggstate_token_name: ByteArray = &quot;AggState&quot;\n","url":"oracle.html#aggstate_token_name"},{"doc":"oracle","title":"reward_acc_token_name","content":"reward_acc_token_name: ByteArray = &quot;RewardAcc&quot;\n","url":"oracle.html#reward_acc_token_name"},{"doc":"oracle","title":"reward_transport_token_name","content":"reward_transport_token_name: ByteArray = &quot;RewardT&quot;\n","url":"oracle.html#reward_transport_token_name"},{"doc":"oracle","title":"oracle","content":" 1. oracle_nfts - this validator will act as one time policy for RewardAccount\n    and as a scaling policy for RewardTransport with AggState,\n    each policy id is unique for one trade pair (ticker), or potentially even multiple tickers with same nodes and fee token;\n 2. oracle_manager - main oracle validator, see OracleRedeemer for list of allowed actions.","url":"oracle.html"},{"doc":"ext/aiken/time","title":"PosixTime","content":"PosixTime = Int\n\n","url":"ext/aiken/time.html#PosixTime"},{"doc":"ext/aiken/time","title":"PosixTimeDiff","content":"PosixTimeDiff = Int\n\n","url":"ext/aiken/time.html#PosixTimeDiff"},{"doc":"ext/aiken/time","title":"ext/aiken/time","content":"","url":"ext/aiken/time.html"},{"doc":"services/time","title":"get_current_time","content":"get_current_time(\n  time_accuracy: PosixTimeDiff,\n  tx_validity_range: ValidityRange,\n) -&gt; PosixTime\n Get the middle of tx validity interval and check time accuracy","url":"services/time.html#get_current_time"},{"doc":"services/time","title":"services/time","content":" Tx validity interval checks:\n 1. tx validity interval should have an upper limit, after which tx could not be submitted, because we want signatures to be expirable.\n 2. tx validity interval should have a lower limit, because we want to guarantee that the tx is produced after a certain moment in time.\n 3. tx validity interval should have a fixed length, which is the time measurement absolute uncertainty.","url":"services/time.html"},{"doc":"oracle/checks","title":"spends_reward_acc_utxo","content":"spends_reward_acc_utxo(\n  script_hash: ScriptHash,\n  reward_acc_nft: Asset,\n  tx_inputs: List&lt;Input&gt;,\n) -&gt; Bool\n","url":"oracle/checks.html#spends_reward_acc_utxo"},{"doc":"oracle/checks","title":"returns_empty_reward_outputs","content":"returns_empty_reward_outputs(\n  script_hash: ScriptHash,\n  reward_transport_nft: Asset,\n  allowed_asset: PolicyId,\n  utxo_count: Int,\n  tx_outputs: List&lt;Output&gt;,\n) -&gt; Bool\n","url":"oracle/checks.html#returns_empty_reward_outputs"},{"doc":"oracle/checks","title":"returns_empty_aggstate_outputs","content":"returns_empty_aggstate_outputs(\n  script_hash: ScriptHash,\n  aggstate_nft: Asset,\n  allowed_asset: PolicyId,\n  utxo_count: Int,\n  tx_outputs: List&lt;Output&gt;,\n) -&gt; Bool\n","url":"oracle/checks.html#returns_empty_aggstate_outputs"},{"doc":"oracle/checks","title":"find_out_datum_and_value","content":"find_out_datum_and_value(\n  tx_outputs: List&lt;Output&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n  allowed_asset: PolicyId,\n) -&gt; (OracleDatum, Value)\n","url":"oracle/checks.html#find_out_datum_and_value"},{"doc":"oracle/checks","title":"find_in_datum","content":"find_in_datum(\n  tx_inputs: List&lt;Input&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n) -&gt; OracleDatum\n","url":"oracle/checks.html#find_in_datum"},{"doc":"oracle/checks","title":"find_in_aggregations","content":"find_in_aggregations(\n  tx_inputs: List&lt;Input&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n) -&gt; List&lt;AnAggregation&gt;\n","url":"oracle/checks.html#find_in_aggregations"},{"doc":"oracle/checks","title":"does_not_produce_own_nft_outputs","content":"does_not_produce_own_nft_outputs(\n  tx_outputs: List&lt;Output&gt;,\n  own_nft_policy_id: PolicyId,\n) -&gt; Bool\n","url":"oracle/checks.html#does_not_produce_own_nft_outputs"},{"doc":"oracle/checks","title":"is_aggstate_expired","content":"is_aggstate_expired(\n  aggstate: Option&lt;AggStateDatum&gt;,\n  tx_validity_range: ValidityRange,\n) -&gt; Bool\n","url":"oracle/checks.html#is_aggstate_expired"},{"doc":"oracle/checks","title":"convert_reward_prices","content":"convert_reward_prices(\n  tx_reference_inputs: List&lt;Input&gt;,\n  tx_validity_range: ValidityRange,\n  rate_nft: Option&lt;Asset&gt;,\n  reward_prices: RewardPrices,\n) -&gt; RewardPrices\n","url":"oracle/checks.html#convert_reward_prices"},{"doc":"oracle/checks","title":"calculate_minimum_fee_amout","content":"calculate_minimum_fee_amout(\n  reward_prices: RewardPrices,\n  nodes_count: Int,\n) -&gt; Int\n","url":"oracle/checks.html#calculate_minimum_fee_amout"},{"doc":"oracle/checks","title":"are_mutable_settings_unchanged","content":"are_mutable_settings_unchanged(\n  in_core_datum: RewardDatum,\n  out_core_datum: RewardDatum,\n) -&gt; Bool\n","url":"oracle/checks.html#are_mutable_settings_unchanged"},{"doc":"oracle/checks","title":"oracle_fees_were_transfered","content":"oracle_fees_were_transfered(\n  fee_token: Asset,\n  aggregations: List&lt;AnAggregation&gt;,\n  in_value: Value,\n  out_value: Value,\n) -&gt; Bool\n","url":"oracle/checks.html#oracle_fees_were_transfered"},{"doc":"oracle/checks","title":"AnAggregation","content":"AnAggregation {\n  median: OracleFeed,\n  message: AggregateMessage,\n  value: Value,\n}\n\nAnAggregation { median: OracleFeed, message: AggregateMessage, value: Value }\n","url":"oracle/checks.html#AnAggregation"},{"doc":"oracle/checks","title":"oracle/checks","content":"","url":"oracle/checks.html"},{"doc":"ext/aiken/math/rational","title":"Percent","content":"Percent = Int\n\n","url":"ext/aiken/math/rational.html#Percent"},{"doc":"ext/aiken/math/rational","title":"coin_precision","content":"coin_precision: Int = 1_000_000\n Typical coin precision, such as lovelace for ada","url":"ext/aiken/math/rational.html#coin_precision"},{"doc":"ext/aiken/math/rational","title":"per_10k","content":"per_10k: Int = 10_000\n","url":"ext/aiken/math/rational.html#per_10k"},{"doc":"ext/aiken/math/rational","title":"per_cent","content":"per_cent: Int = 100\n","url":"ext/aiken/math/rational.html#per_cent"},{"doc":"ext/aiken/math/rational","title":"per_mille","content":"per_mille: Int = 1000\n","url":"ext/aiken/math/rational.html#per_mille"},{"doc":"ext/aiken/math/rational","title":"ext/aiken/math/rational","content":"","url":"ext/aiken/math/rational.html"}]);