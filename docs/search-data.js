window.Aiken.initSearch([{"doc":"services/nft_based_auth","title":"auth_by_nft","content":"auth_by_nft(\n  nft: PolicyId,\n  tx_inputs: List&lt;Input&gt;,\n  tx_outputs: List&lt;Output&gt;,\n) -&gt; Bool\n","url":"services/nft_based_auth.html#auth_by_nft"},{"doc":"services/nft_based_auth","title":"services/nft_based_auth","content":"","url":"services/nft_based_auth.html"},{"doc":"ext/aiken/time","title":"PosixTime","content":"PosixTime = Int\n\n","url":"ext/aiken/time.html#PosixTime"},{"doc":"ext/aiken/time","title":"PosixTimeDiff","content":"PosixTimeDiff = Int\n\n","url":"ext/aiken/time.html#PosixTimeDiff"},{"doc":"ext/aiken/time","title":"ext/aiken/time","content":"","url":"ext/aiken/time.html"},{"doc":"services/multisig","title":"check_multisig","content":"check_multisig(\n  multisig: Multisig,\n  tx_signatories: List&lt;VerificationKeyHash&gt;,\n) -&gt; Bool\n","url":"services/multisig.html#check_multisig"},{"doc":"services/multisig","title":"Multisig","content":"Multisig {\n  allowed_signatories: List&lt;VerificationKeyHash&gt;,\n  required_signatories_count: Int,\n}\n This type represents an entity with multisig capabilities - e.g. a multisig wallet:\n * allowed_signatories - Verification key hashed allowed for authorization\n * required_signatories_count - Minimum required number of signatories for authorization\nMultisig {\n  allowed_signatories: List&lt;VerificationKeyHash&gt;,\n  required_signatories_count: Int,\n}\n","url":"services/multisig.html#Multisig"},{"doc":"services/multisig","title":"services/multisig","content":"","url":"services/multisig.html"},{"doc":"ext/aiken/collection/list","title":"indexed_zip_with","content":"indexed_zip_with(\n  self: List&lt;a&gt;,\n  bs: List&lt;b&gt;,\n  with: fn(Int, a, b) -&gt; result,\n) -&gt; List&lt;result&gt;\n A combination of `zip` and `indexed_map`\n https://github.com/aiken-lang/stdlib/blob/0f88f8ffce60b91ae3e4b3a3f40bab153e494760/lib/aiken/collection/list.ak#L1168\n https://github.com/aiken-lang/stdlib/blob/0f88f8ffce60b91ae3e4b3a3f40bab153e494760/lib/aiken/collection/list.ak#L896","url":"ext/aiken/collection/list.html#indexed_zip_with"},{"doc":"ext/aiken/collection/list","title":"ext/aiken/collection/list","content":"","url":"ext/aiken/collection/list.html"},{"doc":"services/iqr","title":"iqr_fence","content":"iqr_fence(\n  sorted_input: List&lt;Int&gt;,\n  input_length: Int,\n  iqr_multiplier: Rational,\n) -&gt; (Rational, Rational)\n See interquartile range (IQR) and Tukey fences methods for outlier detection","url":"services/iqr.html#iqr_fence"},{"doc":"services/iqr","title":"quantile","content":"quantile(xs: List&lt;Int&gt;, n: Int, q: Rational) -&gt; Rational\n Returns weighted (by proximity) average of the two elements closest to the quantile index q * (n - 1)","url":"services/iqr.html#quantile"},{"doc":"services/iqr","title":"services/iqr","content":" To ensure a more reliable outlier detection using IQR, it&#39;s advisable to have a sample size of at least 20-30 data points,\n i.e. five points per quartile.\n Naturally, minimum number of points is four, to have at least one element in earch quartile,\n but beware that IQR could become useless for sample sizes of 4-10.","url":"services/iqr.html"},{"doc":"services/protocol_token","title":"find_own_protocol_policy_id","content":"find_own_protocol_policy_id(input_value: Value, nft_name: AssetName) -&gt; PolicyId\n Find own protocol NFT inside the value we are spending.\n Note that it&#39;s not required to check_own_protocol_token in tx inputs\n because it&#39;s already been checked for each output.","url":"services/protocol_token.html#find_own_protocol_policy_id"},{"doc":"services/protocol_token","title":"spends_script_utxo_with_nft","content":"spends_script_utxo_with_nft(\n  script_hash: ScriptHash,\n  nft: Asset,\n  tx_inputs: List&lt;Input&gt;,\n) -&gt; Bool\n Find one protocol NFT inside transaction inputs.","url":"services/protocol_token.html#spends_script_utxo_with_nft"},{"doc":"services/protocol_token","title":"find_script_inputs_by_token","content":"find_script_inputs_by_token(\n  tx_inputs: List&lt;Input&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n) -&gt; List&lt;Input&gt;\n Find own protocol NFT inside transaction inputs.\n Note that it&#39;s not required to check_own_protocol_token in tx inputs\n because it&#39;s already been checked for each output.","url":"services/protocol_token.html#find_script_inputs_by_token"},{"doc":"services/protocol_token","title":"spends_protocol_nft_inputs","content":"spends_protocol_nft_inputs(\n  script_hash: ScriptHash,\n  protocol_nft: Asset,\n  utxo_count: Int,\n  tx_inputs: List&lt;Input&gt;,\n) -&gt; Bool\n A convenience function that calls find_script_inputs_by_token\n and also checks number of spent inputs","url":"services/protocol_token.html#spends_protocol_nft_inputs"},{"doc":"services/protocol_token","title":"find_script_outputs_by_token","content":"find_script_outputs_by_token(\n  tx_outputs: List&lt;Output&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n) -&gt; List&lt;Output&gt;\n Find own protocol NFT inside transaction outputs","url":"services/protocol_token.html#find_script_outputs_by_token"},{"doc":"services/protocol_token","title":"find_script_outputs_by_token_allowing_asset","content":"find_script_outputs_by_token_allowing_asset(\n  tx_outputs: List&lt;Output&gt;,\n  script_hash: ScriptHash,\n  allowed_asset: PolicyId,\n  protocol_token: Asset,\n) -&gt; List&lt;Output&gt;\n Find own protocol NFT inside transaction outputs allowing asset","url":"services/protocol_token.html#find_script_outputs_by_token_allowing_asset"},{"doc":"services/protocol_token","title":"check_own_protocol_token","content":"check_own_protocol_token(output_value: Value, protocol_token: Asset) -&gt; Bool\n Returns true if protocol NFT was found and it&#39;s the only asset except lovelace","url":"services/protocol_token.html#check_own_protocol_token"},{"doc":"services/protocol_token","title":"check_own_protocol_token_allowing_asset","content":"check_own_protocol_token_allowing_asset(\n  output_value: Value,\n  allowed_asset: PolicyId,\n  protocol_token: Asset,\n) -&gt; Bool\n Returns true if protocol NFT was found and it&#39;s the only asset except lovelace and one allowed","url":"services/protocol_token.html#check_own_protocol_token_allowing_asset"},{"doc":"services/protocol_token","title":"skip_allowed_asset","content":"skip_allowed_asset(\n  policy_id: PolicyId,\n  name: AssetName,\n  amount: Int,\n  allowed_asset: PolicyId,\n) -&gt; Option&lt;(PolicyId, AssetName, Int)&gt;\n Skips allowed token: e.g. C3 fee payment token","url":"services/protocol_token.html#skip_allowed_asset"},{"doc":"services/protocol_token","title":"services/protocol_token","content":"","url":"services/protocol_token.html"},{"doc":"oracle/redeemer","title":"MintingRedeemer","content":"MintingRedeemer {\n  MintToken\n  ScaleToken\n  BurnToken\n}\n Types of actions for Oracle NFTs (protocol tokens)\n * MintToken  - Oracle start: one time mint for CoreSettings and RewardAccount; any number of mints for RewardTransport and AggState\n * ScaleToken - Scale RewardTransport and AggState UTxOs: any number of mints/burns for RewardTransport and AggState\n * BurnToken  - Oracle close: all tokens are burned\nMintToken\n\nScaleToken\n\nBurnToken\n","url":"oracle/redeemer.html#MintingRedeemer"},{"doc":"oracle/redeemer","title":"OracleRedeemer","content":"OracleRedeemer {\n  OdvAggregate\n  CalculateRewards\n  NodeCollect\n  PlatformCollect\n  UpdateSettings\n  SetFeeConfig\n  AddNodes\n  DelNodes\n  ScaleDown\n  DismissRewards\n  CloseOracle\n  ReopenOracle\n  RemoveOracle\n}\n Types of actions for Oracle smart contract\n * OdvAggregate - user sends on demand validation request together with oracle nodes message collected off-chain\n * CalculateRewards - nodes and platform can calculate reward consensus transferring user provided fees to reward UTxO\n * NodeCollect - oracle node collects rewards\n * PlatformCollect - oracle platform collects rewards\n * UpdateSettings - oracle platform changes consensus settings\n * SetFeeConfig - oracle platform changes reward fee configuration\n * AddNodes - oracle platform adds new nodes\n * DelNodes - oracle platform deletes nodes\n * ScaleDown - oracle platform burns RewardTransport and AggState NFTs, destroying corresponding UTxOs\n * DismissRewards - oracle platform turns RewardTransport UTxOs with pending rewards calculations into NoRewards\n * CloseOracle - oracle platform starts closing period, when nodes can still calculate disregarded rewards\n * ReopenOracle - redeemer for cancelling oracle close, so that platform can suspend oracle operation only temporarily\n * RemoveOracle - oracle closing period ends and platform destroys all UTxOs and all NFTs\nOdvAggregate\n\nCalculateRewards\n\nNodeCollect\n\nPlatformCollect\n\nUpdateSettings\n\nSetFeeConfig\n\nAddNodes\n\nDelNodes\n\nScaleDown\n\nDismissRewards\n\nCloseOracle\n\nReopenOracle\n\nRemoveOracle\n","url":"oracle/redeemer.html#OracleRedeemer"},{"doc":"oracle/redeemer","title":"oracle/redeemer","content":"","url":"oracle/redeemer.html"},{"doc":"oracle/multisig","title":"check_nodes_multisig","content":"check_nodes_multisig(\n  node_feeds: Pairs&lt;NodeId, NodeFeed&gt;,\n  tx_signatories: List&lt;VerificationKeyHash&gt;,\n  nodes: List&lt;Node&gt;,\n  required_node_signatures_count: Int,\n) -&gt; Bool\n","url":"oracle/multisig.html#check_nodes_multisig"},{"doc":"oracle/multisig","title":"oracle/multisig","content":"","url":"oracle/multisig.html"},{"doc":"services/time","title":"get_current_time","content":"get_current_time(\n  time_accuracy: PosixTimeDiff,\n  tx_validity_range: ValidityRange,\n) -&gt; PosixTime\n Get the middle of tx validity interval and check time accuracy","url":"services/time.html#get_current_time"},{"doc":"services/time","title":"services/time","content":" Tx validity interval checks:\n 1. tx validity interval should have an upper limit, after which tx could not be submitted, because we want signatures to be expirable.\n 2. tx validity interval should have a lower limit, because we want to guarantee that the tx is produced after a certain moment in time.\n 3. tx validity interval should have a fixed length, which is the time measurement absolute uncertainty.","url":"services/time.html"},{"doc":"config","title":"aggstate_token_name","content":"aggstate_token_name: ByteArray = &quot;C3AS&quot;\n","url":"config.html#aggstate_token_name"},{"doc":"config","title":"core_settings_token_name","content":"core_settings_token_name: ByteArray = &quot;C3CS&quot;\n","url":"config.html#core_settings_token_name"},{"doc":"config","title":"disallow_less_than_four_nodes","content":"disallow_less_than_four_nodes: Bool = True\n","url":"config.html#disallow_less_than_four_nodes"},{"doc":"config","title":"reward_account_token_name","content":"reward_account_token_name: ByteArray = &quot;C3RA&quot;\n","url":"config.html#reward_account_token_name"},{"doc":"config","title":"reward_transport_token_name","content":"reward_transport_token_name: ByteArray = &quot;C3RT&quot;\n","url":"config.html#reward_transport_token_name"},{"doc":"config","title":"config","content":"","url":"config.html"},{"doc":"oracle/checks","title":"returns_empty_reward_outputs","content":"returns_empty_reward_outputs(\n  script_hash: ScriptHash,\n  reward_transport_nft: Asset,\n  utxo_count: Int,\n  tx_outputs: List&lt;Output&gt;,\n) -&gt; Bool\n","url":"oracle/checks.html#returns_empty_reward_outputs"},{"doc":"oracle/checks","title":"returns_empty_aggstate_outputs","content":"returns_empty_aggstate_outputs(\n  script_hash: ScriptHash,\n  aggstate_nft: Asset,\n  utxo_count: Int,\n  tx_outputs: List&lt;Output&gt;,\n) -&gt; Bool\n","url":"oracle/checks.html#returns_empty_aggstate_outputs"},{"doc":"oracle/checks","title":"find_out_datum_and_value","content":"find_out_datum_and_value(\n  tx_outputs: List&lt;Output&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n) -&gt; (OracleDatum, Value)\n","url":"oracle/checks.html#find_out_datum_and_value"},{"doc":"oracle/checks","title":"find_out_datum_and_value_allowing_asset","content":"find_out_datum_and_value_allowing_asset(\n  tx_outputs: List&lt;Output&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n  allowed_asset: PolicyId,\n) -&gt; (OracleDatum, Value)\n","url":"oracle/checks.html#find_out_datum_and_value_allowing_asset"},{"doc":"oracle/checks","title":"find_in_datum","content":"find_in_datum(\n  tx_inputs: List&lt;Input&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n) -&gt; OracleDatum\n","url":"oracle/checks.html#find_in_datum"},{"doc":"oracle/checks","title":"find_in_aggregations","content":"find_in_aggregations(\n  tx_inputs: List&lt;Input&gt;,\n  script_hash: ScriptHash,\n  protocol_token: Asset,\n) -&gt; List&lt;AnAggregation&gt;\n","url":"oracle/checks.html#find_in_aggregations"},{"doc":"oracle/checks","title":"does_not_produce_own_nft_outputs","content":"does_not_produce_own_nft_outputs(\n  tx_outputs: List&lt;Output&gt;,\n  own_nft_policy_id: PolicyId,\n) -&gt; Bool\n","url":"oracle/checks.html#does_not_produce_own_nft_outputs"},{"doc":"oracle/checks","title":"is_aggstate_expired","content":"is_aggstate_expired(\n  aggstate: Option&lt;AggStateDatum&gt;,\n  tx_validity_range: ValidityRange,\n) -&gt; Bool\n","url":"oracle/checks.html#is_aggstate_expired"},{"doc":"oracle/checks","title":"convert_reward_prices","content":"convert_reward_prices(\n  tx_reference_inputs: List&lt;Input&gt;,\n  tx_validity_range: ValidityRange,\n  rate_nft: Option&lt;Asset&gt;,\n  reward_prices: RewardPrices,\n) -&gt; RewardPrices\n","url":"oracle/checks.html#convert_reward_prices"},{"doc":"oracle/checks","title":"calculate_minimum_fee_amout","content":"calculate_minimum_fee_amout(\n  reward_prices: RewardPrices,\n  nodes_count: Int,\n) -&gt; Int\n","url":"oracle/checks.html#calculate_minimum_fee_amout"},{"doc":"oracle/checks","title":"oracle_fees_were_transfered","content":"oracle_fees_were_transfered(\n  fee_token: Asset,\n  aggregations: List&lt;AnAggregation&gt;,\n  in_value: Value,\n  out_value: Value,\n) -&gt; Bool\n","url":"oracle/checks.html#oracle_fees_were_transfered"},{"doc":"oracle/checks","title":"check_reward_distribution","content":"check_reward_distribution(\n  aggregations: List&lt;AnAggregation&gt;,\n  in_distribution: List&lt;Int&gt;,\n  out_distribution: List&lt;Int&gt;,\n  reward_prices: RewardPrices,\n  iqr_fence_multiplier: Percent,\n) -&gt; Bool\n","url":"oracle/checks.html#check_reward_distribution"},{"doc":"oracle/checks","title":"validate_message_form","content":"validate_message_form(message: AggregateMessage) -&gt; Bool\n","url":"oracle/checks.html#validate_message_form"},{"doc":"oracle/checks","title":"check_settings_sanity","content":"check_settings_sanity(\n  in_settings: OracleSettingsDatum,\n  out_settings: OracleSettingsDatum,\n) -&gt; Bool\n","url":"oracle/checks.html#check_settings_sanity"},{"doc":"oracle/checks","title":"check_fee_settings_sanity","content":"check_fee_settings_sanity(\n  in_settings: OracleSettingsDatum,\n  out_settings: OracleSettingsDatum,\n) -&gt; Bool\n","url":"oracle/checks.html#check_fee_settings_sanity"},{"doc":"oracle/checks","title":"check_closing_does_not_change_settings","content":"check_closing_does_not_change_settings(\n  in_core_datum: OracleSettingsDatum,\n  out_core_datum: OracleSettingsDatum,\n) -&gt; Bool\n","url":"oracle/checks.html#check_closing_does_not_change_settings"},{"doc":"oracle/checks","title":"find_node_id_by_signature","content":"find_node_id_by_signature(\n  tx_signatories: List&lt;VerificationKeyHash&gt;,\n  nodes: List&lt;Node&gt;,\n) -&gt; NodeId\n","url":"oracle/checks.html#find_node_id_by_signature"},{"doc":"oracle/checks","title":"check_node_received_reward","content":"check_node_received_reward(\n  fee_token: Asset,\n  rewarded_node: NodeId,\n  in_distribution: List&lt;Int&gt;,\n  out_distribution: List&lt;Int&gt;,\n  in_value: Value,\n  out_value: Value,\n) -&gt; Bool\n","url":"oracle/checks.html#check_node_received_reward"},{"doc":"oracle/checks","title":"check_platform_received_reward","content":"check_platform_received_reward(\n  fee_token: Asset,\n  reward_distribution: List&lt;Int&gt;,\n  in_value: Value,\n  out_value: Value,\n) -&gt; Bool\n","url":"oracle/checks.html#check_platform_received_reward"},{"doc":"oracle/checks","title":"AnAggregation","content":"AnAggregation {\n  median: OracleFeed,\n  message: AggregateMessage,\n  value: Value,\n}\n\nAnAggregation { median: OracleFeed, message: AggregateMessage, value: Value }\n","url":"oracle/checks.html#AnAggregation"},{"doc":"oracle/checks","title":"oracle/checks","content":"","url":"oracle/checks.html"},{"doc":"oracle/datum","title":"is_oracle_closing","content":"is_oracle_closing(settings: OracleSettingsDatum) -&gt; Bool\n","url":"oracle/datum.html#is_oracle_closing"},{"doc":"oracle/datum","title":"has_no_rewards","content":"has_no_rewards(reward_transport: RewardTransportDatum) -&gt; Bool\n","url":"oracle/datum.html#has_no_rewards"},{"doc":"oracle/datum","title":"AggStateDatum","content":"AggStateDatum {\n  oracle_feed: OracleFeed,\n  expiry_timestamp: PosixTime,\n  created_at: PosixTime,\n}\n AggStateDatum contains an oracle feed - median taken from individual node feeds,\n an expiration timestamp marking time after which AggState can be consumed once again,\n and a created at timestamp for oracle users.\nAggStateDatum {\n  oracle_feed: OracleFeed,\n  expiry_timestamp: PosixTime,\n  created_at: PosixTime,\n}\n","url":"oracle/datum.html#AggStateDatum"},{"doc":"oracle/datum","title":"AggregateMessage","content":"AggregateMessage {\n  node_feeds_sorted_by_feed: Pairs&lt;NodeId, NodeFeed&gt;,\n  node_feeds_count: Int,\n  timestamp: PosixTime,\n}\n\nAggregateMessage {\n  node_feeds_sorted_by_feed: Pairs&lt;NodeId, NodeFeed&gt;,\n  node_feeds_count: Int,\n  timestamp: PosixTime,\n}\n","url":"oracle/datum.html#AggregateMessage"},{"doc":"oracle/datum","title":"FeeConfig","content":"FeeConfig {\n  rate_nft: Option&lt;Asset&gt;,\n  reward_prices: RewardPrices,\n}\n\nFeeConfig { rate_nft: Option&lt;Asset&gt;, reward_prices: RewardPrices }\n","url":"oracle/datum.html#FeeConfig"},{"doc":"oracle/datum","title":"Node","content":"Node {\n  feed_vkh: VerificationKeyHash,\n  payment_vkh: VerificationKeyHash,\n}\n An oracle node has two keys:\n 1. feed_vkh - for verification of node feed inside the AggregateMessage.\n    Node operator does not store any kind of funds on this key, it&#39;s only for signing.\n 2. payment_vkh - exists only for node operator convenience:\n    so that he can pay tx fees and collect node rewards using one vkh.\nNode { feed_vkh: VerificationKeyHash, payment_vkh: VerificationKeyHash }\n","url":"oracle/datum.html#Node"},{"doc":"oracle/datum","title":"NodeFeed","content":"NodeFeed = Int\n\n","url":"oracle/datum.html#NodeFeed"},{"doc":"oracle/datum","title":"NodeId","content":"NodeId = Int\n\n","url":"oracle/datum.html#NodeId"},{"doc":"oracle/datum","title":"OracleConfiguration","content":"OracleConfiguration {\n  platform_auth_nft: PolicyId,\n  closing_period_length: PosixTimeDiff,\n  reward_dismissing_period_length: PosixTimeDiff,\n  fee_token: Asset,\n}\n Immutable oracle settings.\n Rationale for immutability:\n * platform_auth_nft - oracle deployment corresponds to one unchanging &quot;platform&quot;\n * closing_period_length - oracle nodes will be sure that platform won&#39;t update this to a make very short interval\n * reward_dismissing_period_length - oracle nodes will be sure that platform won&#39;t update this to a make very short interval\n * fee_token - oracle nodes will be sure that platform won&#39;t update reward currency\nOracleConfiguration {\n  platform_auth_nft: PolicyId,\n  closing_period_length: PosixTimeDiff,\n  reward_dismissing_period_length: PosixTimeDiff,\n  fee_token: Asset,\n}\n","url":"oracle/datum.html#OracleConfiguration"},{"doc":"oracle/datum","title":"OracleDatum","content":"OracleDatum {\n  OracleSettings(OracleSettingsDatum)\n  RewardAccount(RewardAccountDatum)\n  RewardTransport(RewardTransportDatum)\n  AggState(Option&lt;AggStateDatum&gt;)\n}\n There are four types of oracle utxos:\n 0. OracleSettings - one for each oracle,\n    acts as single point of truth for oracle settings and node list.\n 1. RewardAccount - one for each oracle,\n    acts as single point of truth for reward distribution.\n 2. RewardTransport - many for each oracle, with possibility of scaling their number on demand,\n    users permorm ODV aggregation with those by providing node feeds list constructed off-chain.\n 3. AggState - each AggState utxo is complementary to RewardTransport, it containts the oracle feed value,\n    that will be referenced by a user of a DApp.\nOracleSettings(OracleSettingsDatum)\n\nRewardAccount(RewardAccountDatum)\n\nRewardTransport(RewardTransportDatum)\n\nAggState(Option&lt;AggStateDatum&gt;)\n","url":"oracle/datum.html#OracleDatum"},{"doc":"oracle/datum","title":"OracleFeed","content":"OracleFeed = Int\n\n","url":"oracle/datum.html#OracleFeed"},{"doc":"oracle/datum","title":"OracleSettingsDatum","content":"OracleSettingsDatum {\n  nodes: List&lt;Node&gt;,\n  required_node_signatures_count: Int,\n  fee_info: FeeConfig,\n  aggregation_liveness_period: PosixTimeDiff,\n  time_absolute_uncertainty: PosixTimeDiff,\n  iqr_fence_multiplier: Percent,\n  closing_period_started_at: Option&lt;PosixTime&gt;,\n}\n Mutable oracle settings\nOracleSettingsDatum {\n  nodes: List&lt;Node&gt;,\n  required_node_signatures_count: Int,\n  fee_info: FeeConfig,\n  aggregation_liveness_period: PosixTimeDiff,\n  time_absolute_uncertainty: PosixTimeDiff,\n  iqr_fence_multiplier: Percent,\n  closing_period_started_at: Option&lt;PosixTime&gt;,\n}\n","url":"oracle/datum.html#OracleSettingsDatum"},{"doc":"oracle/datum","title":"RewardAccountDatum","content":"RewardAccountDatum {\n  nodes_to_rewards: List&lt;Int&gt;,\n}\n Reward distribution datum\nRewardAccountDatum { nodes_to_rewards: List&lt;Int&gt; }\n","url":"oracle/datum.html#RewardAccountDatum"},{"doc":"oracle/datum","title":"RewardPrices","content":"RewardPrices {\n  node_fee: Int,\n  platform_fee: Int,\n}\n\nRewardPrices { node_fee: Int, platform_fee: Int }\n","url":"oracle/datum.html#RewardPrices"},{"doc":"oracle/datum","title":"RewardTransportDatum","content":"RewardTransportDatum {\n  NoRewards\n  RewardConsensusPending { oracle_feed: OracleFeed, message: AggregateMessage }\n}\n RewardTransport utxo can be in two states:\n 1. NoRewards - waiting for user to submit tx with OdvAggregate redeemer;\n 2. RewardConsensusPending - waiting to calculate aggregation reward distribution\n    and transfer user provided fees into RewardAccount utxo.\nNoRewards\n\nRewardConsensusPending { oracle_feed: OracleFeed, message: AggregateMessage }\n","url":"oracle/datum.html#RewardTransportDatum"},{"doc":"oracle/datum","title":"oracle/datum","content":"","url":"oracle/datum.html"},{"doc":"ext/aiken/math/rational","title":"Percent","content":"Percent = Int\n\n","url":"ext/aiken/math/rational.html#Percent"},{"doc":"ext/aiken/math/rational","title":"coin_precision","content":"coin_precision: Int = 1_000_000\n Typical coin precision, such as lovelace for ada","url":"ext/aiken/math/rational.html#coin_precision"},{"doc":"ext/aiken/math/rational","title":"per_10k","content":"per_10k: Int = 10_000\n","url":"ext/aiken/math/rational.html#per_10k"},{"doc":"ext/aiken/math/rational","title":"per_cent","content":"per_cent: Int = 100\n","url":"ext/aiken/math/rational.html#per_cent"},{"doc":"ext/aiken/math/rational","title":"per_mille","content":"per_mille: Int = 1000\n","url":"ext/aiken/math/rational.html#per_mille"},{"doc":"ext/aiken/math/rational","title":"ext/aiken/math/rational","content":"","url":"ext/aiken/math/rational.html"},{"doc":"oracle/consensus","title":"median","content":"median(node_feeds_sorted: List&lt;NodeFeed&gt;, node_feeds_count: Int) -&gt; OracleFeed\n","url":"oracle/consensus.html#median"},{"doc":"oracle/consensus","title":"consensus_by_iqr","content":"consensus_by_iqr(\n  node_feeds: Pairs&lt;NodeId, NodeFeed&gt;,\n  node_feeds_count: Int,\n  iqr_fence_multiplier: Percent,\n) -&gt; List&lt;NodeId&gt;\n Returns list of nodes which are not outliers using interquartile range algorithm (IQR).","url":"oracle/consensus.html#consensus_by_iqr"},{"doc":"oracle/consensus","title":"oracle/consensus","content":"","url":"oracle/consensus.html"},{"doc":"ext/cardano/value","title":"Asset","content":"Asset {\n  policy_id: PolicyId,\n  name: AssetName,\n}\n\nAsset { policy_id: PolicyId, name: AssetName }\n","url":"ext/cardano/value.html#Asset"},{"doc":"ext/cardano/value","title":"ext/cardano/value","content":"","url":"ext/cardano/value.html"}]);